use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use async_trait::async_trait;
use std::fs;
use std::process::Command;

/// Document/Script Analyzer - Analyzes payloads (docs, scripts)
pub struct DocAnalyzer;

#[async_trait]
impl Tool for DocAnalyzer {
    fn name(&self) -> &str { "analyze_payload" }
    fn description(&self) -> &str { "Analyzes documents and scripts for malicious content. Args: path (file path)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let path = args["path"].as_str().ok_or(anyhow::anyhow!("Missing path"))?;
        
        // Read file to determine type
        let content = fs::read(path).map_err(|e| anyhow::anyhow!("Failed to read file: {}", e))?;
        let extension = std::path::Path::new(path)
            .extension()
            .and_then(|e| e.to_str())
            .unwrap_or("")
            .to_lowercase();

        let mut results = serde_json::Map::new();
        results.insert("file".to_string(), serde_json::json!(path));
        results.insert("size".to_string(), serde_json::json!(content.len()));

        match extension.as_str() {
            // Office Documents (OLE)
            "doc" | "xls" | "ppt" | "docm" | "xlsm" | "pptm" => {
                results.insert("type".to_string(), serde_json::json!("office_document"));
                
                // Check for OLE header
                let is_ole = content.len() >= 8 && &content[0..8] == b"\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1";
                results.insert("is_ole".to_string(), serde_json::json!(is_ole));
                
                // Try olevba if available
                let olevba = Command::new("olevba")
                    .args(["--json", path])
                    .output();
                
                if let Ok(output) = olevba {
                    let stdout = String::from_utf8_lossy(&output.stdout);
                    if let Ok(parsed) = serde_json::from_str::<Value>(&stdout) {
                        results.insert("vba_analysis".to_string(), parsed);
                    }
                } else {
                    // Manual search for VBA indicators
                    let content_str = String::from_utf8_lossy(&content);
                    let indicators: Vec<&str> = vec![
                        "AutoOpen", "Auto_Open", "Document_Open", "Workbook_Open",
                        "Shell", "WScript.Shell", "PowerShell", "cmd.exe",
                        "CreateObject", "ADODB.Stream", "Scripting.FileSystemObject"
                    ].into_iter()
                    .filter(|&ind| content_str.contains(ind))
                    .collect();
                    
                    results.insert("suspicious_vba_keywords".to_string(), serde_json::json!(indicators));
                }
            },
            
            // PowerShell
            "ps1" | "psm1" | "psd1" => {
                results.insert("type".to_string(), serde_json::json!("powershell"));
                let content_str = String::from_utf8_lossy(&content);
                
                // Detect obfuscation indicators
                let obfuscation_score = calculate_obfuscation_score(&content_str);
                results.insert("obfuscation_score".to_string(), serde_json::json!(obfuscation_score));
                
                // Extract IOCs
                let urls: Vec<&str> = content_str.match_indices("http")
                    .filter_map(|(i, _)| {
                        content_str[i..].split_whitespace().next()
                            .filter(|s| s.starts_with("http"))
                    })
                    .take(10)
                    .collect();
                results.insert("extracted_urls".to_string(), serde_json::json!(urls));
                
                // Suspicious keywords
                let suspicious: Vec<&str> = vec![
                    "IEX", "Invoke-Expression", "DownloadString", "DownloadFile",
                    "FromBase64String", "Bypass", "Hidden", "-enc", "-EncodedCommand",
                    "Net.WebClient", "Start-Process", "New-Object"
                ].into_iter()
                .filter(|&kw| content_str.to_lowercase().contains(&kw.to_lowercase()))
                .collect();
                results.insert("suspicious_keywords".to_string(), serde_json::json!(suspicious));
            },
            
            // JavaScript / VBScript
            "js" | "jse" | "vbs" | "vbe" | "wsf" => {
                results.insert("type".to_string(), serde_json::json!("script"));
                let content_str = String::from_utf8_lossy(&content);
                
                let suspicious: Vec<&str> = vec![
                    "WScript.Shell", "ActiveXObject", "eval", "Run",
                    "CreateObject", "ADODB.Stream", "Scripting.FileSystemObject",
                    "fromCharCode", "unescape", "atob"
                ].into_iter()
                .filter(|&kw| content_str.contains(kw))
                .collect();
                results.insert("suspicious_keywords".to_string(), serde_json::json!(suspicious));
            },
            
            // PDF
            "pdf" => {
                results.insert("type".to_string(), serde_json::json!("pdf"));
                let content_str = String::from_utf8_lossy(&content);
                
                // Count suspicious objects
                let js_count = content_str.matches("/JavaScript").count();
                let launch_count = content_str.matches("/Launch").count();
                let embed_count = content_str.matches("/EmbeddedFile").count();
                let action_count = content_str.matches("/OpenAction").count() + 
                                   content_str.matches("/AA").count();
                
                results.insert("suspicious_objects".to_string(), serde_json::json!({
                    "javascript": js_count,
                    "launch_action": launch_count,
                    "embedded_files": embed_count,
                    "auto_action": action_count
                }));
                
                let risk = if js_count > 0 || launch_count > 0 { "HIGH" }
                    else if embed_count > 0 || action_count > 0 { "MEDIUM" }
                    else { "LOW" };
                results.insert("risk_level".to_string(), serde_json::json!(risk));
            },
            
            _ => {
                results.insert("type".to_string(), serde_json::json!("unknown"));
                results.insert("note".to_string(), serde_json::json!("Unsupported file type for detailed analysis"));
            }
        }

        Ok(serde_json::json!(results))
    }
}

fn calculate_obfuscation_score(content: &str) -> u32 {
    let mut score = 0;
    
    // Check for common obfuscation patterns
    if content.contains("`") { score += 10; } // Backtick obfuscation
    if content.contains("$env:") && content.contains("$env:".to_uppercase().as_str()) { score += 5; }
    if content.matches("-join").count() > 3 { score += 15; }
    if content.matches("[char]").count() > 5 { score += 20; }
    if content.matches("FromBase64").count() > 0 { score += 25; }
    if content.len() > 1000 && content.lines().count() < 10 { score += 30; } // Single long line
    
    // High entropy check (many special chars)
    let special_ratio = content.chars().filter(|c| !c.is_alphanumeric() && !c.is_whitespace()).count() as f32 
                        / content.len() as f32;
    if special_ratio > 0.3 { score += 20; }
    
    score
}
