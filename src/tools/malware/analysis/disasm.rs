use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use async_trait::async_trait;
use iced_x86::{Decoder, DecoderOptions, Formatter, Instruction, IntelFormatter};

pub struct CodeDisassembler;

#[async_trait]
impl Tool for CodeDisassembler {
    fn name(&self) -> &str { "disassemble_code" }
    fn description(&self) -> &str { "Disassembles hex string or raw bytes using iced-x86. Args: hex_code (string), bitness (number, default 64)" }
    
    async fn execute(&self, args: Value) -> Result<Value> {
        let hex_code = args["hex_code"].as_str().ok_or(anyhow::anyhow!("Missing hex_code"))?;
        let bitness = args["bitness"].as_u64().unwrap_or(64) as u32;
        
        // Remove spaces and 0x prefix if present
        let clean_hex = hex_code.replace(" ", "").replace("0x", "");
        let bytes = hex::decode(&clean_hex).map_err(|e| anyhow::anyhow!("Invalid hex: {}", e))?;
        
        let mut decoder = Decoder::new(bitness, &bytes, DecoderOptions::NONE);
        let mut instruction = Instruction::default();
        let mut output = Vec::new();
        let mut formatter = IntelFormatter::new();

        // Optional: Set RIP (Instruction Pointer) if provided in args
        let rip = args["rip"].as_u64().unwrap_or(0);
        decoder.set_ip(rip);

        while decoder.can_decode() {
            decoder.decode_out(&mut instruction);
            
            let mut output_string = String::new();
            formatter.format(&instruction, &mut output_string);
            
            output.push(serde_json::json!({
                "address": format!("0x{:X}", instruction.ip()),
                "bytes": clean_hex[((instruction.ip() - rip) as usize * 2)..((instruction.next_ip() - rip) as usize * 2)].to_string(), // Approximate slice logic might need adjustment based on exact byte consumption
                "mnemonic": format!("{:?}", instruction.mnemonic()),
                "op_code": output_string
            }));
        }

        Ok(serde_json::json!({ "instructions": output }))
    }
}
