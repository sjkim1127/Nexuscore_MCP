use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use async_trait::async_trait;
use base64::{Engine as _, engine::general_purpose};
use rc4::{Rc4, KeyInit, StreamCipher};
use aes::Aes128;
use cbc::Decryptor;
use cbc::cipher::{BlockDecryptMut, KeyIvInit, block_padding::Pkcs7};

type Aes128CbcDecryptor = Decryptor<Aes128>;

pub struct ConfigExtractor;

#[async_trait]
impl Tool for ConfigExtractor {
    fn name(&self) -> &str { "config_extractor" }
    fn description(&self) -> &str { "Decodes obfuscated data. Args: method (xor_bruteforce/base64/rc4/aes_cbc_128), data (hex/string), key (hex), iv (hex)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let method = args["method"].as_str().ok_or(anyhow::anyhow!("Missing method"))?;
        let data_str = args["data"].as_str().ok_or(anyhow::anyhow!("Missing data"))?;
        
        let parse_hex = |s: &str| hex::decode(s.replace(" ", "")).unwrap_or_default();

        match method {
            "xor_bruteforce" => {
                let bytes = parse_hex(data_str);
                let mut candidates = Vec::new();
                for key in 0..=255u8 {
                    let decoded: Vec<u8> = bytes.iter().map(|b| b ^ key).collect();
                    if let Ok(s) = String::from_utf8(decoded.clone()) {
                        // Heuristic: Look for URLs, IPs, or common strings
                        if s.contains("http") || s.contains(".com") || s.contains(".exe") || s.contains("\\") {
                            candidates.push(serde_json::json!({ 
                                "key": format!("0x{:02X}", key), 
                                "result": s.chars().take(200).collect::<String>() 
                            }));
                        }
                    }
                }
                if candidates.is_empty() {
                    // Return top 3 most printable results
                    let mut scores: Vec<(u8, usize, String)> = (0..=255u8).map(|key| {
                        let decoded: Vec<u8> = bytes.iter().map(|b| b ^ key).collect();
                        let printable = decoded.iter().filter(|&&b| b >= 0x20 && b < 0x7F).count();
                        let s = String::from_utf8_lossy(&decoded).chars().take(100).collect();
                        (key, printable, s)
                    }).collect();
                    scores.sort_by(|a, b| b.1.cmp(&a.1));
                    for (key, _, s) in scores.into_iter().take(3) {
                        candidates.push(serde_json::json!({ "key": format!("0x{:02X}", key), "result": s }));
                    }
                }
                Ok(serde_json::json!({ "candidates": candidates }))
            },
            "base64" => {
                let decoded = general_purpose::STANDARD.decode(data_str)
                    .map_err(|e| anyhow::anyhow!("Base64 decode failed: {}", e))?;
                Ok(serde_json::json!({ 
                    "decoded_hex": hex::encode(&decoded), 
                    "decoded_str": String::from_utf8_lossy(&decoded) 
                }))
            },
            "rc4" => {
                let mut data = parse_hex(data_str);
                let key_hex = args["key"].as_str().unwrap_or("");
                let key = parse_hex(key_hex);
                
                if key.is_empty() {
                    return Err(anyhow::anyhow!("RC4 requires a key"));
                }
                
                let mut rc4 = Rc4::new_from_slice(&key)
                    .map_err(|_| anyhow::anyhow!("Invalid RC4 Key"))?;
                rc4.apply_keystream(&mut data);
                
                Ok(serde_json::json!({ 
                    "decrypted_hex": hex::encode(&data), 
                    "decrypted_str": String::from_utf8_lossy(&data) 
                }))
            },
            "aes_cbc_128" => {
                let data = parse_hex(data_str);
                let key = parse_hex(args["key"].as_str().unwrap_or(""));
                let iv = parse_hex(args["iv"].as_str().unwrap_or(""));

                if key.len() != 16 || iv.len() != 16 {
                    return Err(anyhow::anyhow!("AES-128 requires 16-byte key and 16-byte IV"));
                }
                if data.len() % 16 != 0 {
                    return Err(anyhow::anyhow!("AES-CBC data must be 16-byte aligned"));
                }

                let decryptor = Aes128CbcDecryptor::new(key.as_slice().into(), iv.as_slice().into());
                let mut buf = data.clone();
                let decrypted = decryptor.decrypt_padded_mut::<Pkcs7>(&mut buf)
                    .map_err(|e| anyhow::anyhow!("AES Decrypt failed: {:?}", e))?;

                Ok(serde_json::json!({ 
                    "decrypted_hex": hex::encode(decrypted), 
                    "decrypted_str": String::from_utf8_lossy(decrypted) 
                }))
            },
            _ => Err(anyhow::anyhow!("Unknown method: {}. Use xor_bruteforce, base64, rc4, or aes_cbc_128", method))
        }
    }
}
