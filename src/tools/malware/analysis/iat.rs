use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use async_trait::async_trait;
use tokio::process::Command;
use std::env;

/// Default Scylla executable name
const DEFAULT_SCYLLA_EXE: &str = "ScyllaTest.exe";

pub struct IatFixer;

#[async_trait]
impl Tool for IatFixer {
    fn name(&self) -> &str { "iat_fixer" }
    fn description(&self) -> &str { "Rebuilds Import Address Table (IAT) using Scylla (CLI). Args: dumped_file, original_pid, oep" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let dumped_file = args["dumped_file"].as_str().ok_or(anyhow::anyhow!("Missing dumped_file"))?;
        let pid = args["original_pid"].as_u64().ok_or(anyhow::anyhow!("Missing original_pid"))?;
        let oep = args["oep"].as_str().unwrap_or("0"); // OEP as hex string

        // Get Scylla path from environment or use default
        let scylla_exe = env::var("SCYLLA_PATH").unwrap_or_else(|_| DEFAULT_SCYLLA_EXE.to_string());

        // Scylla CLI usage: ScyllaTest.exe -pid 1234 -dump dumped.exe -oep 0x401000 -fix
        let output = Command::new(&scylla_exe)
            .arg("-pid").arg(pid.to_string())
            .arg("-dump").arg(dumped_file)
            .arg("-oep").arg(oep)
            .arg("-fix")
            .output()
            .await;
            
        // Since Scylla CLI might not be standard, we return a guidance message if failed.
        match output {
            Ok(out) => {
                 if out.status.success() {
                     Ok(serde_json::json!({ "status": "iat_fixed", "output": String::from_utf8_lossy(&out.stdout) }))
                 } else {
                     Err(anyhow::anyhow!("Scylla failed: {}", String::from_utf8_lossy(&out.stderr)))
                 }
            },
            Err(e) => {
                // Return a clear error that the tool might be missing
                Err(anyhow::anyhow!("Failed to execute Scylla. Ensure ScyllaTest.exe is in PATH. Error: {}", e))
            }
        }
    }
}
