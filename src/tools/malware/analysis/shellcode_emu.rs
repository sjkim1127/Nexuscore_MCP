use anyhow::Result;
use serde_json::Value;
use crate::tools::{Tool, ToolSchema, ParamDef};
use crate::utils::response::StandardResponse;
use async_trait::async_trait;
use unicorn_engine::{Unicorn, RegisterX86};
use unicorn_engine::unicorn_const::{Arch, Mode, Permission};
use std::time::Instant;

pub struct ShellcodeEmulator;

#[async_trait]
impl Tool for ShellcodeEmulator {
    fn name(&self) -> &str { "emulate_shellcode" }
    fn description(&self) -> &str { "Emulates shellcode using Unicorn Engine. Args: code (hex), arch (x86/x64), steps (optional)" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("code", "string", true, "Shellcode in hex format"),
            ParamDef::new("arch", "string", false, "Architecture: x86 or x64 (default)"),
            ParamDef::new("steps", "number", false, "Max emulation steps (default: 1000)"),
        ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let hex_code = match args["code"].as_str() {
            Some(c) => c,
            None => return Ok(StandardResponse::error(tool_name, "Missing code")),
        };
        let arch_str = args["arch"].as_str().unwrap_or("x64");
        let steps = args["steps"].as_u64().unwrap_or(1000) as usize;

        let code = match hex::decode(hex_code.replace(" ", "")) {
            Ok(c) => c,
            Err(e) => return Ok(StandardResponse::error(tool_name, &format!("Hex decode failed: {}", e))),
        };
        
        let (arch, mode) = match arch_str {
            "x86" => (Arch::X86, Mode::MODE_32),
            _ => (Arch::X86, Mode::MODE_64),
        };

        let mut unicorn = match Unicorn::new(arch, mode) {
            Ok(u) => u,
            Err(e) => return Ok(StandardResponse::error(tool_name, &format!("Unicorn init failed: {:?}", e))),
        };

        let address: u64 = 0x1000000;
        let size: usize = 2 * 1024 * 1024;
        
        if unicorn.mem_map(address, size, Permission::ALL).is_err() {
            return Ok(StandardResponse::error(tool_name, "Memory map failed"));
        }
        if unicorn.mem_write(address, &code).is_err() {
            return Ok(StandardResponse::error(tool_name, "Memory write failed"));
        }

        let emu_result = unicorn.emu_start(address, address + code.len() as u64, 0, steps);
        let stopped_reason = match &emu_result {
            Ok(_) => "completed",
            Err(e) => return Ok(StandardResponse::partial(tool_name, serde_json::json!({
                "arch": arch_str,
                "code_size": code.len(),
                "stopped_early": true
            }), &format!("{:?}", e))),
        };

        let mut regs = serde_json::Map::new();
        if arch == Arch::X86 {
            for (name, reg) in [("RAX", RegisterX86::RAX), ("RBX", RegisterX86::RBX), ("RCX", RegisterX86::RCX), ("RDX", RegisterX86::RDX), ("RIP", RegisterX86::RIP), ("RSP", RegisterX86::RSP)] {
                if let Ok(v) = unicorn.reg_read(reg as i32) {
                    regs.insert(name.to_string(), serde_json::json!(format!("0x{:X}", v)));
                }
            }
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "arch": arch_str,
            "code_size": code.len(),
            "max_steps": steps,
            "stopped_reason": stopped_reason,
            "registers": regs
        }), start))
    }
}
