use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use crate::engine::frida_handler;
use async_trait::async_trait;
use std::fs;

/// Memory Dump Tool - Dumps process memory to file or returns as hex
pub struct MemoryDumper;

#[async_trait]
impl Tool for MemoryDumper {
    fn name(&self) -> &str { "dump_memory" }

    fn description(&self) -> &str {
        "Dumps memory from a process. Args: pid (number), address (hex string), size (number), output_path (optional string)"
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;
        let address = args["address"].as_str().ok_or(anyhow::anyhow!("Missing address"))?;
        let size = args["size"].as_u64().ok_or(anyhow::anyhow!("Missing size"))? as usize;
        let output_path = args["output_path"].as_str();

        // Build inline script for memory reading
        let script = format!(r#"
            var addr = ptr("{}");
            var size = {};
            var data = Memory.readByteArray(addr, size);
            if (data) {{
                var hex = "";
                var bytes = new Uint8Array(data);
                for (var i = 0; i < bytes.length; i++) {{
                    hex += ("0" + bytes[i].toString(16)).slice(-2);
                }}
                send({{ type: "memory_dump", hex: hex }});
            }} else {{
                send({{ type: "error", message: "Failed to read memory" }});
            }}
        "#, address, size);

        frida_handler::execute_script(pid, &script)?;
        
        // Note: In a real implementation, we'd need to receive the message from Frida.
        // For now, we return acknowledgement. Full implementation requires message handling.
        
        Ok(serde_json::json!({
            "status": "dump_initiated",
            "pid": pid,
            "address": address,
            "size": size,
            "note": "Memory data will be sent via Frida message handler"
        }))
    }
}

/// Memory Patcher - Patches bytes in process memory at runtime
pub struct MemoryPatcher;

#[async_trait]
impl Tool for MemoryPatcher {
    fn name(&self) -> &str { "patch_memory" }

    fn description(&self) -> &str {
        "Patches memory in a process at runtime. Args: pid (number), address (hex string), bytes (hex string)"
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;
        let address = args["address"].as_str().ok_or(anyhow::anyhow!("Missing address"))?;
        let bytes_hex = args["bytes"].as_str().ok_or(anyhow::anyhow!("Missing bytes"))?;

        // Convert hex string to byte array representation for JS
        let js_bytes: Vec<String> = (0..bytes_hex.len())
            .step_by(2)
            .filter_map(|i| {
                bytes_hex.get(i..i+2).map(|s| format!("0x{}", s))
            })
            .collect();

        let script = format!(r#"
            var addr = ptr("{}");
            var bytes = [{}];
            Memory.patchCode(addr, bytes.length, function(code) {{
                for (var i = 0; i < bytes.length; i++) {{
                    code.putByte(bytes[i]);
                }}
            }});
            send({{ type: "patch_complete", address: addr.toString(), size: bytes.length }});
        "#, address, js_bytes.join(", "));

        frida_handler::execute_script(pid, &script)?;

        Ok(serde_json::json!({
            "status": "patched",
            "pid": pid,
            "address": address,
            "bytes": bytes_hex,
            "size": bytes_hex.len() / 2
        }))
    }
}
