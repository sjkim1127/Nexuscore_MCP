use anyhow::Result;
use serde_json::Value;
use crate::tools::{Tool, ToolSchema, ParamDef};
use crate::utils::response::StandardResponse;
use async_trait::async_trait;
use std::fs;
use std::time::Instant;

pub struct DocAnalyzer;

#[async_trait]
impl Tool for DocAnalyzer {
    fn name(&self) -> &str { "analyze_payload" }
    fn description(&self) -> &str { "Analyzes documents and scripts for malicious content. Args: path" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![ ParamDef::new("path", "string", true, "Path to file") ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let path = match args["path"].as_str() {
            Some(p) => p,
            None => return Ok(StandardResponse::error(tool_name, "Missing path")),
        };
        
        let content = match fs::read(path) {
            Ok(c) => c,
            Err(e) => return Ok(StandardResponse::error(tool_name, &format!("Read failed: {}", e))),
        };
        
        let ext = std::path::Path::new(path).extension().and_then(|e| e.to_str()).unwrap_or("").to_lowercase();
        let content_str = String::from_utf8_lossy(&content);
        
        let (file_type, suspicious) = match ext.as_str() {
            "doc" | "xls" | "docm" | "xlsm" => {
                let kw: Vec<&str> = ["AutoOpen", "Shell", "PowerShell", "CreateObject"]
                    .iter().filter(|k| content_str.contains(*k)).cloned().collect();
                ("office", kw)
            },
            "ps1" | "psm1" => {
                let kw: Vec<&str> = ["IEX", "Invoke-Expression", "DownloadString", "FromBase64String", "-enc"]
                    .iter().filter(|k| content_str.to_lowercase().contains(&k.to_lowercase())).cloned().collect();
                ("powershell", kw)
            },
            "js" | "vbs" => {
                let kw: Vec<&str> = ["WScript.Shell", "eval", "ActiveXObject", "CreateObject"]
                    .iter().filter(|k| content_str.contains(*k)).cloned().collect();
                ("script", kw)
            },
            "pdf" => {
                let kw: Vec<&str> = ["/JavaScript", "/Launch", "/OpenAction", "/EmbeddedFile"]
                    .iter().filter(|k| content_str.contains(*k)).cloned().collect();
                ("pdf", kw)
            },
            _ => ("unknown", vec![]),
        };

        let risk = if suspicious.len() > 3 { "HIGH" } else if suspicious.len() > 0 { "MEDIUM" } else { "LOW" };

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "file": path,
            "size": content.len(),
            "type": file_type,
            "risk": risk,
            "suspicious_keywords": suspicious
        }), start))
    }
}
