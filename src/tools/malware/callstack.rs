use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use crate::engine::frida_handler;
use async_trait::async_trait;

/// Callstack Tracer - Records backtraces on function calls
pub struct CallstackTracer;

#[async_trait]
impl Tool for CallstackTracer {
    fn name(&self) -> &str { "trace_callstack" }

    fn description(&self) -> &str {
        "Traces callstack when a function is called. Args: pid (number), module (string), function (string)"
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;
        let module = args["module"].as_str().ok_or(anyhow::anyhow!("Missing module"))?;
        let function = args["function"].as_str().ok_or(anyhow::anyhow!("Missing function"))?;

        let script = format!(r#"
            var targetFunc = Module.getExportByName("{}", "{}");
            if (targetFunc) {{
                Interceptor.attach(targetFunc, {{
                    onEnter: function(args) {{
                        var bt = Thread.backtrace(this.context, Backtracer.ACCURATE)
                            .map(DebugSymbol.fromAddress);
                        
                        var frames = [];
                        for (var i = 0; i < bt.length; i++) {{
                            frames.push(bt[i].toString());
                        }}
                        
                        send({{
                            type: 'callstack',
                            function: '{}',
                            module: '{}',
                            tid: Process.getCurrentThreadId(),
                            frames: frames
                        }});
                    }}
                }});
                send({{ type: 'tracer_installed', module: '{}', function: '{}' }});
            }} else {{
                send({{ type: 'error', message: 'Function not found' }});
            }}
        "#, module, function, function, module, module, function);

        frida_handler::execute_script(pid, &script)?;

        Ok(serde_json::json!({
            "status": "tracer_installed",
            "pid": pid,
            "module": module,
            "function": function,
            "message": "Callstack will be recorded on each function call."
        }))
    }
}

/// Address-based Callstack Tracer
pub struct AddressTracer;

#[async_trait]
impl Tool for AddressTracer {
    fn name(&self) -> &str { "trace_address" }

    fn description(&self) -> &str {
        "Traces callstack when an address is executed. Args: pid (number), address (hex string)"
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;
        let address = args["address"].as_str().ok_or(anyhow::anyhow!("Missing address"))?;

        let script = format!(r#"
            var addr = ptr("{}");
            Interceptor.attach(addr, {{
                onEnter: function(args) {{
                    var bt = Thread.backtrace(this.context, Backtracer.ACCURATE)
                        .map(DebugSymbol.fromAddress);
                    
                    var frames = [];
                    for (var i = 0; i < bt.length; i++) {{
                        frames.push(bt[i].toString());
                    }}
                    
                    send({{
                        type: 'callstack',
                        address: addr.toString(),
                        tid: Process.getCurrentThreadId(),
                        frames: frames
                    }});
                }}
            }});
            send({{ type: 'tracer_installed', address: addr.toString() }});
        "#, address);

        frida_handler::execute_script(pid, &script)?;

        Ok(serde_json::json!({
            "status": "tracer_installed",
            "pid": pid,
            "address": address
        }))
    }
}
