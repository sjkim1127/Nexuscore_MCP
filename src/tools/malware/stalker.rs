use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use crate::engine::frida_handler;
use crate::utils::response::StandardResponse;
use async_trait::async_trait;
use std::time::Instant;

/// Execution Stalker - Traces CPU instruction flow using Frida Stalker
pub struct ExecutionStalker;

#[async_trait]
impl Tool for ExecutionStalker {
    fn name(&self) -> &str { "trace_execution" }
    fn description(&self) -> &str { "Traces CPU execution flow (basic blocks) using Frida Stalker. Args: pid (number), duration_ms (default 5000)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();

        let pid = match args["pid"].as_u64() {
            Some(p) => p as u32,
            None => return Ok(StandardResponse::error(tool_name, "Missing pid")),
        };
        let duration = args["duration_ms"].as_u64().unwrap_or(5000);

        let script = format!(r#"
            var threads = Process.enumerateThreads();
            var targetThreadId = threads[0].id;

            console.log("[*] Stalking thread: " + targetThreadId);

            var blocks = {{}};
            var blockCount = 0;
            var eventQueue = [];
            var lastFlush = Date.now();
            var BATCH_SIZE = 50;
            var FLUSH_INTERVAL = 1000;

            function flushEvents() {{
                if (eventQueue.length > 0) {{
                    send({{ "type": "block_batch", "count": eventQueue.length, "addresses": eventQueue }});
                    eventQueue = [];
                    lastFlush = Date.now();
                }}
            }}

            Stalker.follow(targetThreadId, {{
                events: {{
                    call: false,
                    ret: false,
                    exec: false,
                    block: true,
                    compile: false
                }},
                onReceive: function (events) {{
                    var evs = Stalker.parse(events, {{ annotate: false, bigEndian: false }});
                    evs.forEach(function (ev) {{
                        var start = ev[0];
                        var addr = start.toString();
                        if (!blocks[addr]) {{
                            blocks[addr] = 1;
                            blockCount++;
                            eventQueue.push(addr);
                        }}
                    }});

                    if (eventQueue.length >= BATCH_SIZE || Date.now() - lastFlush > FLUSH_INTERVAL) {{
                        flushEvents();
                    }}
                }}
            }});

            setTimeout(function() {{
                flushEvents();
                Stalker.unfollow(targetThreadId);
                Stalker.garbageCollect();
                send({{ "type": "stalking_complete", "unique_blocks": blockCount }});
            }}, {});
        "#, duration);

        if let Err(e) = frida_handler::execute_script(pid, &script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid,
            "duration_ms": duration,
            "batch_size": 50,
            "note": "Execution blocks will be streamed via Frida messages"
        }), start))
    }
}
