use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use crate::utils::response::StandardResponse;
use async_trait::async_trait;
use std::collections::HashMap;
use std::process::{Command, Stdio, Child, ChildStdin};
use std::sync::Mutex;
use std::io::{Write, BufRead, BufReader};
use std::thread;
use std::sync::mpsc::{channel, Receiver};
use std::time::Instant;

/// Global session store
static SESSIONS: std::sync::OnceLock<Mutex<SessionStore>> = std::sync::OnceLock::new();

fn get_sessions() -> &'static Mutex<SessionStore> {
    SESSIONS.get_or_init(|| Mutex::new(SessionStore::new()))
}

struct DebugSession {
    child: Child,
    stdin: ChildStdin,
    output_rx: Receiver<String>,
    pid: u32,
}

struct SessionStore {
    sessions: HashMap<String, DebugSession>,
    next_id: u32,
}

impl SessionStore {
    fn new() -> Self {
        Self {
            sessions: HashMap::new(),
            next_id: 1,
        }
    }

    fn create_session(&mut self, target: &str, attach_pid: Option<u32>) -> Result<String> {
        let session_id = format!("session_{}", self.next_id);
        self.next_id += 1;

        let mut cmd = Command::new("cdb.exe");
        
        if let Some(pid) = attach_pid {
            cmd.args(["-p", &pid.to_string()]);
        } else {
            cmd.args(["-o", target]);
        }

        cmd.stdin(Stdio::piped())
           .stdout(Stdio::piped())
           .stderr(Stdio::piped());

        let mut child = cmd.spawn()
            .map_err(|e| anyhow::anyhow!("Failed to start cdb.exe: {}", e))?;

        let stdin = child.stdin.take()
            .ok_or_else(|| anyhow::anyhow!("Failed to get stdin"))?;
        
        let stdout = child.stdout.take()
            .ok_or_else(|| anyhow::anyhow!("Failed to get stdout"))?;

        let (tx, rx) = channel::<String>();
        
        thread::spawn(move || {
            let reader = BufReader::new(stdout);
            for line in reader.lines() {
                if let Ok(line) = line {
                    let _ = tx.send(line);
                }
            }
        });

        let pid = child.id();
        
        self.sessions.insert(session_id.clone(), DebugSession {
            child,
            stdin,
            output_rx: rx,
            pid,
        });

        Ok(session_id)
    }

    fn send_command(&mut self, session_id: &str, command: &str) -> Result<Vec<String>> {
        let session = self.sessions.get_mut(session_id)
            .ok_or_else(|| anyhow::anyhow!("Session not found: {}", session_id))?;

        writeln!(session.stdin, "{}", command)?;
        session.stdin.flush()?;

        std::thread::sleep(std::time::Duration::from_millis(100));

        let mut output = Vec::new();
        while let Ok(line) = session.output_rx.try_recv() {
            output.push(line);
        }

        Ok(output)
    }

    fn end_session(&mut self, session_id: &str) -> Result<()> {
        if let Some(mut session) = self.sessions.remove(session_id) {
            let _ = writeln!(session.stdin, "q");
            let _ = session.stdin.flush();
            let _ = session.child.wait();
        }
        Ok(())
    }

    fn list_sessions(&self) -> Vec<(String, u32)> {
        self.sessions.iter()
            .map(|(id, s)| (id.clone(), s.pid))
            .collect()
    }
}

/// Start a new debug session
pub struct SessionStart;

#[async_trait]
impl Tool for SessionStart {
    fn name(&self) -> &str { "session_start" }
    fn description(&self) -> &str { "Start a persistent debug session. Args: path (exe) OR pid (attach to existing). Returns session_id." }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        let mut store = get_sessions().lock().unwrap();
        
        let session_id = if let Some(pid) = args["pid"].as_u64() {
            match store.create_session("", Some(pid as u32)) {
                Ok(id) => id,
                Err(e) => return Ok(StandardResponse::error(tool_name, &e.to_string())),
            }
        } else if let Some(path) = args["path"].as_str() {
            match store.create_session(path, None) {
                Ok(id) => id,
                Err(e) => return Ok(StandardResponse::error(tool_name, &e.to_string())),
            }
        } else {
            return Ok(StandardResponse::error(tool_name, "Provide 'path' or 'pid'"));
        };

        std::thread::sleep(std::time::Duration::from_millis(500));
        let output = store.send_command(&session_id, "").unwrap_or_default();

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "session_id": session_id,
            "startup_output": output.join("\n")
        }), start))
    }
}

/// Send command to existing session
pub struct SessionCommand;

#[async_trait]
impl Tool for SessionCommand {
    fn name(&self) -> &str { "session_command" }
    fn description(&self) -> &str { "Send command to debug session. Args: session_id, command (string)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();

        let session_id = match args["session_id"].as_str() {
            Some(s) => s,
            None => return Ok(StandardResponse::error(tool_name, "Missing session_id")),
        };
        let command = match args["command"].as_str() {
            Some(c) => c,
            None => return Ok(StandardResponse::error(tool_name, "Missing command")),
        };

        let mut store = get_sessions().lock().unwrap();
        let output = match store.send_command(session_id, command) {
            Ok(o) => o,
            Err(e) => return Ok(StandardResponse::error(tool_name, &e.to_string())),
        };

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "session_id": session_id,
            "command": command,
            "output": output
        }), start))
    }
}

/// Send multiple commands to session
pub struct SessionBatch;

#[async_trait]
impl Tool for SessionBatch {
    fn name(&self) -> &str { "session_batch" }
    fn description(&self) -> &str { "Send multiple commands to session. Args: session_id, commands (array)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();

        let session_id = match args["session_id"].as_str() {
            Some(s) => s,
            None => return Ok(StandardResponse::error(tool_name, "Missing session_id")),
        };
        let commands: Vec<String> = match args["commands"].as_array() {
            Some(arr) => arr.iter().filter_map(|v| v.as_str().map(String::from)).collect(),
            None => return Ok(StandardResponse::error(tool_name, "Missing commands array")),
        };

        let mut store = get_sessions().lock().unwrap();
        let mut results = Vec::new();

        for cmd in &commands {
            let output = store.send_command(session_id, cmd).unwrap_or_default();
            results.push(serde_json::json!({
                "command": cmd,
                "output": output
            }));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "session_id": session_id,
            "results": results
        }), start))
    }
}

/// End debug session
pub struct SessionEnd;

#[async_trait]
impl Tool for SessionEnd {
    fn name(&self) -> &str { "session_end" }
    fn description(&self) -> &str { "End a debug session. Args: session_id" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let tool_name = self.name();

        let session_id = match args["session_id"].as_str() {
            Some(s) => s,
            None => return Ok(StandardResponse::error(tool_name, "Missing session_id")),
        };

        let mut store = get_sessions().lock().unwrap();
        store.end_session(session_id)?;

        Ok(StandardResponse::success(tool_name, serde_json::json!({
            "session_id": session_id,
            "ended": true
        })))
    }
}

/// List all active sessions
pub struct SessionList;

#[async_trait]
impl Tool for SessionList {
    fn name(&self) -> &str { "session_list" }
    fn description(&self) -> &str { "List all active debug sessions" }

    async fn execute(&self, _args: Value) -> Result<Value> {
        let tool_name = self.name();
        let store = get_sessions().lock().unwrap();
        let sessions: Vec<_> = store.list_sessions()
            .into_iter()
            .map(|(id, pid)| serde_json::json!({ "session_id": id, "cdb_pid": pid }))
            .collect();

        Ok(StandardResponse::success(tool_name, serde_json::json!({
            "active_sessions": sessions,
            "count": sessions.len()
        })))
    }
}

/// Common cdb.exe command reference
pub struct CdbCommands;

#[async_trait]
impl Tool for CdbCommands {
    fn name(&self) -> &str { "debug_help" }
    fn description(&self) -> &str { "Get common cdb.exe debugger commands reference" }

    async fn execute(&self, _args: Value) -> Result<Value> {
        let tool_name = self.name();
        Ok(StandardResponse::success(tool_name, serde_json::json!({
            "workflow": [
                "1. session_start(path='/path/to/exe') → get session_id",
                "2. session_command(session_id, 'bp main') → set breakpoint",
                "3. session_command(session_id, 'g') → run",
                "4. session_command(session_id, 'r') → view registers",
                "5. session_end(session_id) → cleanup"
            ],
            "execution": { "g": "Go", "p": "Step over", "t": "Step into", "gu": "Step out" },
            "breakpoints": { "bp <addr>": "Set", "bc *": "Clear all", "bl": "List" },
            "memory": { "db": "Bytes", "dd": "Dwords", "dq": "Qwords" },
            "disassembly": { "u": "Unassemble", "uf": "Function" },
            "registers": { "r": "Show", "r reg=val": "Set" },
            "stack": { "k": "Trace", "~*k": "All threads" }
        })))
    }
}
