use anyhow::Result;
use serde_json::Value;
use crate::tools::{Tool, ToolSchema, ParamDef};
use crate::utils::response::StandardResponse;
use crate::engine::frida_handler;
use async_trait::async_trait;
use std::time::Instant;

pub struct MemoryDumper;

#[async_trait]
impl Tool for MemoryDumper {
    fn name(&self) -> &str { "dump_memory" }
    fn description(&self) -> &str { "Dumps process memory. Args: pid, address (hex), size" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("pid", "number", true, "Target process ID"),
            ParamDef::new("address", "string", true, "Memory address in hex"),
            ParamDef::new("size", "number", true, "Bytes to dump"),
        ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() { Some(p) => p as u32, None => return Ok(StandardResponse::error(tool_name, "Missing pid")) };
        let address = match args["address"].as_str() { Some(a) => a, None => return Ok(StandardResponse::error(tool_name, "Missing address")) };
        let size = match args["size"].as_u64() { Some(s) => s, None => return Ok(StandardResponse::error(tool_name, "Missing size")) };

        let script = format!(r#"
            var data = Memory.readByteArray(ptr("{}"), {});
            if (data) {{
                var hex = Array.from(new Uint8Array(data)).map(b => ('0'+b.toString(16)).slice(-2)).join('');
                send({{type:'dump', hex:hex}});
            }}
        "#, address, size);

        if let Err(e) = frida_handler::execute_script(pid, &script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid, "address": address, "size": size
        }), start))
    }
}

pub struct MemoryPatcher;

#[async_trait]
impl Tool for MemoryPatcher {
    fn name(&self) -> &str { "patch_memory" }
    fn description(&self) -> &str { "Patches memory at runtime. Args: pid, address (hex), bytes (hex)" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("pid", "number", true, "Target process ID"),
            ParamDef::new("address", "string", true, "Memory address in hex"),
            ParamDef::new("bytes", "string", true, "Patch bytes in hex"),
        ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() { Some(p) => p as u32, None => return Ok(StandardResponse::error(tool_name, "Missing pid")) };
        let address = match args["address"].as_str() { Some(a) => a, None => return Ok(StandardResponse::error(tool_name, "Missing address")) };
        let bytes_hex = match args["bytes"].as_str() { Some(b) => b, None => return Ok(StandardResponse::error(tool_name, "Missing bytes")) };

        let js_bytes: Vec<String> = (0..bytes_hex.len()).step_by(2)
            .filter_map(|i| bytes_hex.get(i..i+2).map(|s| format!("0x{}", s)))
            .collect();

        let script = format!(r#"
            Memory.patchCode(ptr("{}"), {}, function(code) {{
                [{}].forEach(b => code.putByte(b));
            }});
            send({{type:'patched'}});
        "#, address, js_bytes.len(), js_bytes.join(","));

        if let Err(e) = frida_handler::execute_script(pid, &script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid, "address": address, "size": bytes_hex.len() / 2
        }), start))
    }
}
