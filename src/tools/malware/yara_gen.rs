use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use async_trait::async_trait;
use std::fs;
use std::collections::HashMap;

/// Auto YARA Rule Generator
pub struct YaraGenerator;

#[async_trait]
impl Tool for YaraGenerator {
    fn name(&self) -> &str { "generate_yara" }
    fn description(&self) -> &str { "Generates YARA detection rules from a sample. Args: path (file) or hex_data (hex string)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        // Get binary data
        let data: Vec<u8> = if let Some(path) = args["path"].as_str() {
            fs::read(path).map_err(|e| anyhow::anyhow!("Failed to read file: {}", e))?
        } else if let Some(hex) = args["hex_data"].as_str() {
            hex::decode(hex.replace(" ", "")).map_err(|e| anyhow::anyhow!("Invalid hex: {}", e))?
        } else {
            return Err(anyhow::anyhow!("Provide 'path' or 'hex_data'"));
        };

        let rule_name = args["name"].as_str().unwrap_or("generated_rule");
        
        // Extract unique strings
        let strings = extract_strings(&data, 6);
        let unique_strings = find_unique_strings(&strings, 5);
        
        // Extract hex patterns (look for interesting byte sequences)
        let hex_patterns = extract_hex_patterns(&data);
        
        // Calculate file hash
        let sha256 = format!("{:x}", sha2::Sha256::digest(&data));
        
        // Generate YARA rule
        let yara_rule = format!(r#"rule {} {{
    meta:
        description = "Auto-generated rule by NexusCore"
        sha256 = "{}"
        date = "{}"
    
    strings:
{}
{}
    
    condition:
        uint16(0) == 0x5A4D and {} of them
}}
"#,
            rule_name,
            sha256,
            chrono::Local::now().format("%Y-%m-%d"),
            // String definitions
            unique_strings.iter().enumerate()
                .map(|(i, s)| format!("        $s{} = \"{}\"", i, escape_yara_string(s)))
                .collect::<Vec<_>>()
                .join("\n"),
            // Hex patterns
            hex_patterns.iter().enumerate()
                .map(|(i, h)| format!("        $h{} = {{ {} }}", i, h))
                .collect::<Vec<_>>()
                .join("\n"),
            // Condition threshold
            (unique_strings.len() + hex_patterns.len()) / 2
        );

        Ok(serde_json::json!({
            "status": "generated",
            "sha256": sha256,
            "strings_extracted": unique_strings.len(),
            "hex_patterns": hex_patterns.len(),
            "yara_rule": yara_rule
        }))
    }
}

fn extract_strings(data: &[u8], min_len: usize) -> Vec<String> {
    let mut strings = Vec::new();
    let mut current = String::new();
    
    for &byte in data {
        if byte >= 0x20 && byte < 0x7F {
            current.push(byte as char);
        } else {
            if current.len() >= min_len {
                strings.push(current.clone());
            }
            current.clear();
        }
    }
    if current.len() >= min_len {
        strings.push(current);
    }
    
    strings
}

fn find_unique_strings(strings: &[String], max: usize) -> Vec<String> {
    // Count occurrences
    let mut counts: HashMap<&String, usize> = HashMap::new();
    for s in strings {
        *counts.entry(s).or_insert(0) += 1;
    }
    
    // Filter: unique, interesting, not too common
    let mut candidates: Vec<_> = strings.iter()
        .filter(|s| {
            let count = counts.get(s).unwrap_or(&0);
            *count == 1 
                && s.len() >= 8 
                && s.len() <= 100
                && !s.chars().all(|c| c == ' ' || c == '.')
                && !is_common_string(s)
        })
        .collect();
    
    // Sort by length (prefer longer strings)
    candidates.sort_by(|a, b| b.len().cmp(&a.len()));
    
    candidates.into_iter()
        .take(max)
        .cloned()
        .collect()
}

fn is_common_string(s: &str) -> bool {
    let common = [
        "Microsoft", "Windows", "Copyright", "Version", "http://", "https://",
        "This program", "cannot be run", ".dll", ".exe", "KERNEL32"
    ];
    common.iter().any(|c| s.contains(c))
}

fn extract_hex_patterns(data: &[u8]) -> Vec<String> {
    let mut patterns = Vec::new();
    
    // Look for interesting patterns at common locations
    // Entry point area (after PE header, ~0x400 offset if PE)
    if data.len() > 0x500 {
        let entry_bytes: Vec<String> = data[0x400..0x410].iter()
            .map(|b| format!("{:02X}", b))
            .collect();
        patterns.push(entry_bytes.join(" "));
    }
    
    // Look for unique 16-byte sequences with high entropy
    if data.len() > 32 {
        for chunk in data.chunks(16).skip(10).take(100) {
            if chunk.len() == 16 {
                let entropy = calculate_entropy(chunk);
                if entropy > 3.0 && entropy < 7.0 {
                    let hex: Vec<String> = chunk.iter()
                        .map(|b| format!("{:02X}", b))
                        .collect();
                    patterns.push(hex.join(" "));
                    if patterns.len() >= 3 {
                        break;
                    }
                }
            }
        }
    }
    
    patterns
}

fn calculate_entropy(data: &[u8]) -> f64 {
    let mut freq = [0u32; 256];
    for &byte in data {
        freq[byte as usize] += 1;
    }
    
    let len = data.len() as f64;
    freq.iter()
        .filter(|&&c| c > 0)
        .map(|&c| {
            let p = c as f64 / len;
            -p * p.log2()
        })
        .sum()
}

fn escape_yara_string(s: &str) -> String {
    s.replace("\\", "\\\\")
     .replace("\"", "\\\"")
     .replace("\n", "\\n")
     .replace("\r", "\\r")
}
