use anyhow::Result;
use serde_json::Value;
use crate::tools::{Tool, ToolSchema, ParamDef};
use crate::utils::response::StandardResponse;
use crate::engine::frida_handler;
use async_trait::async_trait;
use std::time::Instant;

pub struct ChildTrapper;

#[async_trait]
impl Tool for ChildTrapper {
    fn name(&self) -> &str { "monitor_children" }
    fn description(&self) -> &str { "Detects child process creation. Args: pid (number)" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![ ParamDef::new("pid", "number", true, "Target process ID") ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() {
            Some(p) => p as u32,
            None => return Ok(StandardResponse::error(tool_name, "Missing pid")),
        };

        let script = r#"
            ['CreateProcessW', 'CreateProcessA'].forEach(function(api) {
                var fn = Module.findExportByName('kernel32.dll', api);
                if (fn) {
                    Interceptor.attach(fn, {
                        onEnter: function(args) { this.cmd = args[1].isNull() ? '' : args[1].readUtf16String(); },
                        onLeave: function(retval) {
                            if (retval.toInt32() !== 0) send({type:'child', api:api, cmd:this.cmd});
                        }
                    });
                }
            });
            send({type:'active', apis:['CreateProcessW','CreateProcessA']});
        "#;

        if let Err(e) = frida_handler::execute_script(pid, script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid,
            "hooked_apis": ["CreateProcessW", "CreateProcessA"]
        }), start))
    }
}
