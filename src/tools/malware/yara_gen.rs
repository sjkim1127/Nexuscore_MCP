use anyhow::Result;
use serde_json::Value;
use crate::tools::{Tool, ToolSchema, ParamDef};
use crate::utils::response::StandardResponse;
use async_trait::async_trait;
use std::fs;
use std::collections::HashMap;
use std::time::Instant;

pub struct YaraGenerator;

#[async_trait]
impl Tool for YaraGenerator {
    fn name(&self) -> &str { "generate_yara" }
    fn description(&self) -> &str { "Generates YARA detection rules from a sample. Args: path (file) or hex_data (hex string)" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("path", "string", false, "Path to malware sample"),
            ParamDef::new("hex_data", "string", false, "Sample data in hex"),
            ParamDef::new("name", "string", false, "Rule name (optional)"),
        ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let data: Vec<u8> = if let Some(path) = args["path"].as_str() {
            match fs::read(path) {
                Ok(d) => d,
                Err(e) => return Ok(StandardResponse::error(tool_name, &format!("Failed to read: {}", e))),
            }
        } else if let Some(hex) = args["hex_data"].as_str() {
            match hex::decode(hex.replace(" ", "")) {
                Ok(d) => d,
                Err(e) => return Ok(StandardResponse::error(tool_name, &format!("Invalid hex: {}", e))),
            }
        } else {
            return Ok(StandardResponse::error(tool_name, "Provide 'path' or 'hex_data'"));
        };

        let rule_name = args["name"].as_str().unwrap_or("generated_rule");
        let strings = extract_strings(&data, 6);
        let unique_strings = find_unique_strings(&strings, 5);
        let hex_patterns = extract_hex_patterns(&data);
        let sha256 = format!("{:x}", sha2::Sha256::digest(&data));
        
        let yara_rule = format!(r#"rule {} {{
    meta:
        sha256 = "{}"
        date = "{}"
    strings:
{}
{}
    condition:
        uint16(0) == 0x5A4D and {} of them
}}"#,
            rule_name, sha256, chrono::Local::now().format("%Y-%m-%d"),
            unique_strings.iter().enumerate().map(|(i, s)| format!("        $s{} = \"{}\"", i, escape_yara_string(s))).collect::<Vec<_>>().join("\n"),
            hex_patterns.iter().enumerate().map(|(i, h)| format!("        $h{} = {{ {} }}", i, h)).collect::<Vec<_>>().join("\n"),
            (unique_strings.len() + hex_patterns.len()) / 2
        );

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "sha256": sha256,
            "strings_found": unique_strings.len(),
            "hex_patterns": hex_patterns.len(),
            "yara_rule": yara_rule
        }), start))
    }
}

fn extract_strings(data: &[u8], min_len: usize) -> Vec<String> {
    let mut strings = Vec::new();
    let mut current = String::new();
    for &byte in data {
        if byte >= 0x20 && byte < 0x7F { current.push(byte as char); }
        else { if current.len() >= min_len { strings.push(current.clone()); } current.clear(); }
    }
    if current.len() >= min_len { strings.push(current); }
    strings
}

fn find_unique_strings(strings: &[String], max: usize) -> Vec<String> {
    let mut counts: HashMap<&String, usize> = HashMap::new();
    for s in strings { *counts.entry(s).or_insert(0) += 1; }
    let mut candidates: Vec<_> = strings.iter()
        .filter(|s| *counts.get(s).unwrap_or(&0) == 1 && s.len() >= 8 && s.len() <= 100 && !is_common_string(s))
        .collect();
    candidates.sort_by(|a, b| b.len().cmp(&a.len()));
    candidates.into_iter().take(max).cloned().collect()
}

fn is_common_string(s: &str) -> bool {
    ["Microsoft", "Windows", "Copyright", "Version", ".dll", ".exe", "KERNEL32"].iter().any(|c| s.contains(c))
}

fn extract_hex_patterns(data: &[u8]) -> Vec<String> {
    let mut patterns = Vec::new();
    if data.len() > 0x500 {
        patterns.push(data[0x400..0x410].iter().map(|b| format!("{:02X}", b)).collect::<Vec<_>>().join(" "));
    }
    patterns.truncate(3);
    patterns
}

fn escape_yara_string(s: &str) -> String {
    s.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n")
}
