use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use crate::engine::frida_handler;
use async_trait::async_trait;

/// Return Value Spoofer - Forces a function to return a specific value
pub struct ReturnSpoofer;

#[async_trait]
impl Tool for ReturnSpoofer {
    fn name(&self) -> &str { "spoof_return" }

    fn description(&self) -> &str {
        "Forces a function to return a specific value. Args: pid (number), module (string), function (string), return_value (number)"
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;
        let module = args["module"].as_str().ok_or(anyhow::anyhow!("Missing module"))?;
        let function = args["function"].as_str().ok_or(anyhow::anyhow!("Missing function"))?;
        let return_value = args["return_value"].as_i64().unwrap_or(1);

        let script = format!(r#"
            var targetFunc = Module.getExportByName("{}", "{}");
            if (targetFunc) {{
                Interceptor.attach(targetFunc, {{
                    onLeave: function(retval) {{
                        retval.replace(ptr({}));
                        send({{
                            type: 'spoof_triggered',
                            module: '{}',
                            function: '{}',
                            original: retval.toString(),
                            spoofed: {}
                        }});
                    }}
                }});
                send({{ type: 'spoof_installed', module: '{}', function: '{}', value: {} }});
            }} else {{
                send({{ type: 'error', message: 'Function not found' }});
            }}
        "#, module, function, return_value, module, function, return_value, module, function, return_value);

        frida_handler::execute_script(pid, &script)?;

        Ok(serde_json::json!({
            "status": "spoof_installed",
            "pid": pid,
            "module": module,
            "function": function,
            "forced_return": return_value
        }))
    }
}

/// Address-based Return Spoofer - For functions without exports
pub struct AddressSpoofer;

#[async_trait]
impl Tool for AddressSpoofer {
    fn name(&self) -> &str { "spoof_address" }

    fn description(&self) -> &str {
        "Forces an address to return a specific value. Args: pid (number), address (hex string), return_value (number)"
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;
        let address = args["address"].as_str().ok_or(anyhow::anyhow!("Missing address"))?;
        let return_value = args["return_value"].as_i64().unwrap_or(1);

        let script = format!(r#"
            var addr = ptr("{}");
            Interceptor.attach(addr, {{
                onLeave: function(retval) {{
                    retval.replace(ptr({}));
                    send({{
                        type: 'spoof_triggered',
                        address: addr.toString(),
                        spoofed: {}
                    }});
                }}
            }});
            send({{ type: 'spoof_installed', address: addr.toString(), value: {} }});
        "#, address, return_value, return_value, return_value);

        frida_handler::execute_script(pid, &script)?;

        Ok(serde_json::json!({
            "status": "spoof_installed",
            "pid": pid,
            "address": address,
            "forced_return": return_value
        }))
    }
}
