use anyhow::Result;
use serde_json::Value;
use crate::tools::{Tool, ToolSchema, ParamDef};
use crate::utils::response::StandardResponse;
use async_trait::async_trait;
use base64::{Engine as _, engine::general_purpose};
use rc4::{Rc4, KeyInit, StreamCipher};
use aes::Aes128;
use cbc::Decryptor;
use cbc::cipher::{BlockDecryptMut, KeyIvInit, block_padding::Pkcs7};
use std::time::Instant;

type Aes128CbcDecryptor = Decryptor<Aes128>;

pub struct ConfigExtractor;

#[async_trait]
impl Tool for ConfigExtractor {
    fn name(&self) -> &str { "config_extractor" }
    fn description(&self) -> &str { "Decodes obfuscated data. Args: method (xor_bruteforce/base64/rc4/aes_cbc_128), data, key, iv" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("method", "string", true, "Decoding method: xor_bruteforce, base64, rc4, aes_cbc_128"),
            ParamDef::new("data", "string", true, "Data to decode (hex or base64 string)"),
            ParamDef::new("key", "string", false, "Key in hex (for rc4/aes)"),
            ParamDef::new("iv", "string", false, "IV in hex (for aes)"),
        ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let method = match args["method"].as_str() {
            Some(m) => m,
            None => return Ok(StandardResponse::error(tool_name, "Missing method")),
        };
        let data_str = match args["data"].as_str() {
            Some(d) => d,
            None => return Ok(StandardResponse::error(tool_name, "Missing data")),
        };
        
        let parse_hex = |s: &str| hex::decode(s.replace(" ", "")).unwrap_or_default();

        match method {
            "xor_bruteforce" => {
                let bytes = parse_hex(data_str);
                let mut candidates = Vec::new();
                for key in 0..=255u8 {
                    let decoded: Vec<u8> = bytes.iter().map(|b| b ^ key).collect();
                    if let Ok(s) = String::from_utf8(decoded.clone()) {
                        if s.contains("http") || s.contains(".com") || s.contains(".exe") {
                            candidates.push(serde_json::json!({ "key": format!("0x{:02X}", key), "result": s.chars().take(200).collect::<String>() }));
                        }
                    }
                }
                Ok(StandardResponse::success_timed(tool_name, serde_json::json!({ "method": method, "candidates": candidates }), start))
            },
            "base64" => {
                match general_purpose::STANDARD.decode(data_str) {
                    Ok(decoded) => Ok(StandardResponse::success_timed(tool_name, serde_json::json!({ 
                        "method": method,
                        "decoded_hex": hex::encode(&decoded), 
                        "decoded_str": String::from_utf8_lossy(&decoded) 
                    }), start)),
                    Err(e) => Ok(StandardResponse::error(tool_name, &format!("Base64 decode failed: {}", e))),
                }
            },
            "rc4" => {
                let mut data = parse_hex(data_str);
                let key = parse_hex(args["key"].as_str().unwrap_or(""));
                if key.is_empty() {
                    return Ok(StandardResponse::error(tool_name, "RC4 requires a key"));
                }
                match Rc4::new_from_slice(&key) {
                    Ok(mut rc4) => {
                        rc4.apply_keystream(&mut data);
                        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({ 
                            "method": method,
                            "decrypted_hex": hex::encode(&data), 
                            "decrypted_str": String::from_utf8_lossy(&data) 
                        }), start))
                    },
                    Err(_) => Ok(StandardResponse::error(tool_name, "Invalid RC4 key")),
                }
            },
            "aes_cbc_128" => {
                let data = parse_hex(data_str);
                let key = parse_hex(args["key"].as_str().unwrap_or(""));
                let iv = parse_hex(args["iv"].as_str().unwrap_or(""));
                if key.len() != 16 || iv.len() != 16 {
                    return Ok(StandardResponse::error(tool_name, "AES-128 requires 16-byte key and IV"));
                }
                let decryptor = Aes128CbcDecryptor::new(key.as_slice().into(), iv.as_slice().into());
                let mut buf = data.clone();
                match decryptor.decrypt_padded_mut::<Pkcs7>(&mut buf) {
                    Ok(decrypted) => Ok(StandardResponse::success_timed(tool_name, serde_json::json!({ 
                        "method": method,
                        "decrypted_hex": hex::encode(decrypted), 
                        "decrypted_str": String::from_utf8_lossy(decrypted) 
                    }), start)),
                    Err(e) => Ok(StandardResponse::error(tool_name, &format!("AES decrypt failed: {:?}", e))),
                }
            },
            _ => Ok(StandardResponse::error(tool_name, &format!("Unknown method: {}", method))),
        }
    }
}
