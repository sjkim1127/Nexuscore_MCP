use anyhow::Result;
use serde_json::Value;
use crate::tools::{Tool, ToolSchema, ParamDef};
use crate::utils::response::StandardResponse;
use crate::engine::frida_handler;
use async_trait::async_trait;
use std::time::Instant;

const CATEGORIES: &[&str] = &["file", "registry", "network", "memory", "process"];

pub struct ApiMonitor;

#[async_trait]
impl Tool for ApiMonitor {
    fn name(&self) -> &str { "api_monitor" }
    fn description(&self) -> &str { "Monitors Windows API calls in a process. Args: pid (number), categories (array of: 'file', 'registry', 'network', 'memory', 'process')" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("pid", "number", true, "Target process ID"),
            ParamDef::new("categories", "array", false, "API categories to monitor"),
        ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() {
            Some(p) => p as u32,
            None => return Ok(StandardResponse::error(tool_name, "Missing pid")),
        };

        let categories: Vec<String> = if let Some(cats) = args["categories"].as_array() {
            cats.iter().filter_map(|v| v.as_str()).filter(|c| CATEGORIES.contains(c)).map(|s| s.to_string()).collect()
        } else {
            CATEGORIES.iter().map(|s| s.to_string()).collect()
        };

        let config_json = serde_json::json!({ "categories": categories });
        let script = format!(r#"var monitorConfig = {};{}"#, config_json, include_str!("../../resources/scripts/api_monitor.js"));

        if let Err(e) = frida_handler::execute_script(pid, &script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid,
            "categories": categories
        }), start))
    }
}

pub struct FileMonitor;

#[async_trait]
impl Tool for FileMonitor {
    fn name(&self) -> &str { "file_monitor" }
    fn description(&self) -> &str { "Monitors file operations. Args: pid (number)" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![ ParamDef::new("pid", "number", true, "Target process ID") ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() {
            Some(p) => p as u32,
            None => return Ok(StandardResponse::error(tool_name, "Missing pid")),
        };

        let script = format!(r#"var monitorConfig = {{ categories: ['file'] }};{}"#, include_str!("../../resources/scripts/api_monitor.js"));
        if let Err(e) = frida_handler::execute_script(pid, &script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid,
            "category": "file",
            "apis": ["CreateFileW", "WriteFile", "DeleteFileW"]
        }), start))
    }
}

pub struct RegistryMonitor;

#[async_trait]
impl Tool for RegistryMonitor {
    fn name(&self) -> &str { "registry_monitor" }
    fn description(&self) -> &str { "Monitors registry operations. Args: pid (number)" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![ ParamDef::new("pid", "number", true, "Target process ID") ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() {
            Some(p) => p as u32,
            None => return Ok(StandardResponse::error(tool_name, "Missing pid")),
        };

        let script = format!(r#"var monitorConfig = {{ categories: ['registry'] }};{}"#, include_str!("../../resources/scripts/api_monitor.js"));
        if let Err(e) = frida_handler::execute_script(pid, &script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid,
            "category": "registry",
            "apis": ["RegCreateKeyExW", "RegSetValueExW", "RegDeleteKeyW"]
        }), start))
    }
}

pub struct NetworkMonitor;

#[async_trait]
impl Tool for NetworkMonitor {
    fn name(&self) -> &str { "network_monitor" }
    fn description(&self) -> &str { "Monitors network operations. Args: pid (number)" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![ ParamDef::new("pid", "number", true, "Target process ID") ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() {
            Some(p) => p as u32,
            None => return Ok(StandardResponse::error(tool_name, "Missing pid")),
        };

        let script = format!(r#"var monitorConfig = {{ categories: ['network'] }};{}"#, include_str!("../../resources/scripts/api_monitor.js"));
        if let Err(e) = frida_handler::execute_script(pid, &script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid,
            "category": "network",
            "apis": ["connect", "send", "recv", "GetAddrInfoW"]
        }), start))
    }
}

pub struct InjectionMonitor;

#[async_trait]
impl Tool for InjectionMonitor {
    fn name(&self) -> &str { "injection_monitor" }
    fn description(&self) -> &str { "Monitors for process injection techniques. Args: pid (number)" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![ ParamDef::new("pid", "number", true, "Target process ID") ])
    }

    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        
        let pid = match args["pid"].as_u64() {
            Some(p) => p as u32,
            None => return Ok(StandardResponse::error(tool_name, "Missing pid")),
        };

        let script = format!(r#"var monitorConfig = {{ categories: ['process', 'memory'] }};{}"#, include_str!("../../resources/scripts/api_monitor.js"));
        if let Err(e) = frida_handler::execute_script(pid, &script) {
            return Ok(StandardResponse::error(tool_name, &e.to_string()));
        }

        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({
            "pid": pid,
            "categories": ["process", "memory"],
            "apis": ["CreateRemoteThread", "WriteProcessMemory", "VirtualAllocEx"]
        }), start))
    }
}
