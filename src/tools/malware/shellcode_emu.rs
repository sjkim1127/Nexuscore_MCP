use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use async_trait::async_trait;
use unicorn_engine::{Unicorn, RegisterX86};
use unicorn_engine::unicorn_const::{Arch, Mode, Permission};

pub struct ShellcodeEmulator;

#[async_trait]
impl Tool for ShellcodeEmulator {
    fn name(&self) -> &str { "emulate_shellcode" }
    fn description(&self) -> &str { "Emulates shellcode using Unicorn Engine. Args: code (hex), arch (x86/x64), steps (optional)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let hex_code = args["code"].as_str().ok_or(anyhow::anyhow!("Missing code"))?;
        let arch_str = args["arch"].as_str().unwrap_or("x64");
        let steps = args["steps"].as_u64().unwrap_or(1000) as usize;

        let code = hex::decode(hex_code.replace(" ", ""))?;
        
        let (arch, mode) = match arch_str {
            "x86" => (Arch::X86, Mode::MODE_32),
            "x64" => (Arch::X86, Mode::MODE_64),
            _ => (Arch::X86, Mode::MODE_64),
        };

        let mut unicorn = Unicorn::new(arch, mode)
            .map_err(|e| anyhow::anyhow!("Unicorn init failed: {:?}", e))?;

        // 2MB 메모리 할당 (0x1000000)
        let address: u64 = 0x1000000;
        let size: usize = 2 * 1024 * 1024;
        unicorn.mem_map(address, size, Permission::ALL)
            .map_err(|e| anyhow::anyhow!("Mem map failed: {:?}", e))?;
        unicorn.mem_write(address, &code)
            .map_err(|e| anyhow::anyhow!("Mem write failed: {:?}", e))?;

        // 에뮬레이션 시작
        let emu_result = unicorn.emu_start(address, address + code.len() as u64, 0, steps);
        let stopped_reason = match &emu_result {
            Ok(_) => "completed".to_string(),
            Err(e) => format!("{:?}", e),
        };

        // 결과 레지스터 읽기 (x64 기준)
        let mut regs = serde_json::Map::new();
        if arch == Arch::X86 {
            let rax = unicorn.reg_read(RegisterX86::RAX as i32).unwrap_or(0);
            let rbx = unicorn.reg_read(RegisterX86::RBX as i32).unwrap_or(0);
            let rcx = unicorn.reg_read(RegisterX86::RCX as i32).unwrap_or(0);
            let rdx = unicorn.reg_read(RegisterX86::RDX as i32).unwrap_or(0);
            let rip = unicorn.reg_read(RegisterX86::RIP as i32).unwrap_or(0);
            let rsp = unicorn.reg_read(RegisterX86::RSP as i32).unwrap_or(0);
            regs.insert("RAX".to_string(), serde_json::json!(format!("0x{:X}", rax)));
            regs.insert("RBX".to_string(), serde_json::json!(format!("0x{:X}", rbx)));
            regs.insert("RCX".to_string(), serde_json::json!(format!("0x{:X}", rcx)));
            regs.insert("RDX".to_string(), serde_json::json!(format!("0x{:X}", rdx)));
            regs.insert("RIP".to_string(), serde_json::json!(format!("0x{:X}", rip)));
            regs.insert("RSP".to_string(), serde_json::json!(format!("0x{:X}", rsp)));
        }

        Ok(serde_json::json!({
            "status": "emulated",
            "arch": arch_str,
            "code_size": code.len(),
            "max_steps": steps,
            "stopped_reason": stopped_reason,
            "registers": regs
        }))
    }
}
