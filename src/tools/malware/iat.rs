use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use async_trait::async_trait;
use tokio::process::Command;

pub struct IatFixer;

#[async_trait]
impl Tool for IatFixer {
    fn name(&self) -> &str { "iat_fixer" }
    fn description(&self) -> &str { "Rebuilds Import Address Table (IAT) using Scylla (CLI). Args: dumped_file, original_pid, oep" }
    
    async fn execute(&self, args: Value) -> Result<Value> {
        let dumped_file = args["dumped_file"].as_str().ok_or(anyhow::anyhow!("Missing dumped_file"))?;
        let pid = args["original_pid"].as_u64().ok_or(anyhow::anyhow!("Missing original_pid"))?;
        let oep = args["oep"].as_str().unwrap_or("0"); // OEP as hex string
        
        // Scylla CLI usage example (Hypothetical, depends on Scylla build)
        // ScyllaTest.exe -pid 1234 -dump dumped.exe -oep 0x401000 -fix
        let output = Command::new("ScyllaTest.exe") // User must have this in PATH
            .arg("-pid").arg(pid.to_string())
            .arg("-dump").arg(dumped_file)
            .arg("-oep").arg(oep)
            .arg("-fix")
            .output()
            .await;
            
        // Since Scylla CLI might not be standard, we return a guidance message if failed.
        match output {
            Ok(out) => {
                 if out.status.success() {
                     Ok(serde_json::json!({ "status": "iat_fixed", "output": String::from_utf8_lossy(&out.stdout) }))
                 } else {
                     Err(anyhow::anyhow!("Scylla failed: {}", String::from_utf8_lossy(&out.stderr)))
                 }
            },
            Err(e) => {
                // Return a clear error that the tool might be missing
                Err(anyhow::anyhow!("Failed to execute Scylla. Ensure ScyllaTest.exe is in PATH. Error: {}", e))
            }
        }
    }
}
