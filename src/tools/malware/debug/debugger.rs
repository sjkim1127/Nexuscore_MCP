use anyhow::Result;
use serde_json::Value;
use crate::tools::{Tool, ToolSchema, ParamDef};
use crate::utils::response::StandardResponse;
use async_trait::async_trait;
use std::collections::HashMap;
use std::process::{Command, Stdio, Child, ChildStdin};
use std::sync::Mutex;
use std::io::{Write, BufRead, BufReader};
use std::thread;
use std::sync::mpsc::{channel, Receiver};
use std::time::Instant;

/// Global session store
static SESSIONS: std::sync::OnceLock<Mutex<SessionStore>> = std::sync::OnceLock::new();

fn get_sessions() -> &'static Mutex<SessionStore> {
    SESSIONS.get_or_init(|| Mutex::new(SessionStore::new()))
}

struct DebugSession {
    child: Child,
    stdin: ChildStdin,
    output_rx: Receiver<String>,
    pid: u32,
}

struct SessionStore {
    sessions: HashMap<String, DebugSession>,
    next_id: u32,
}

impl SessionStore {
    fn new() -> Self {
        Self { sessions: HashMap::new(), next_id: 1 }
    }

    fn create_session(&mut self, target: &str, attach_pid: Option<u32>) -> Result<String> {
        let session_id = format!("session_{}", self.next_id);
        self.next_id += 1;

        let mut cmd = Command::new("cdb.exe");
        if let Some(pid) = attach_pid {
            cmd.args(["-p", &pid.to_string()]);
        } else {
            cmd.args(["-o", target]);
        }

        cmd.stdin(Stdio::piped()).stdout(Stdio::piped()).stderr(Stdio::piped());
        let mut child = cmd.spawn().map_err(|e| anyhow::anyhow!("Failed to start cdb.exe: {}", e))?;

        let stdin = child.stdin.take().ok_or_else(|| anyhow::anyhow!("Failed to get stdin"))?;
        let stdout = child.stdout.take().ok_or_else(|| anyhow::anyhow!("Failed to get stdout"))?;

        let (tx, rx) = channel::<String>();
        thread::spawn(move || {
            let reader = BufReader::new(stdout);
            for line in reader.lines().flatten() { let _ = tx.send(line); }
        });

        let pid = child.id();
        self.sessions.insert(session_id.clone(), DebugSession { child, stdin, output_rx: rx, pid });
        Ok(session_id)
    }

    fn send_command(&mut self, session_id: &str, command: &str) -> Result<Vec<String>> {
        let session = self.sessions.get_mut(session_id).ok_or_else(|| anyhow::anyhow!("Session not found"))?;
        writeln!(session.stdin, "{}", command)?;
        session.stdin.flush()?;
        std::thread::sleep(std::time::Duration::from_millis(100));
        let mut output = Vec::new();
        while let Ok(line) = session.output_rx.try_recv() { output.push(line); }
        Ok(output)
    }

    fn end_session(&mut self, session_id: &str) -> Result<()> {
        if let Some(mut session) = self.sessions.remove(session_id) {
            let _ = writeln!(session.stdin, "q");
            let _ = session.stdin.flush();
            let _ = session.child.wait();
        }
        Ok(())
    }

    fn list_sessions(&self) -> Vec<(String, u32)> {
        self.sessions.iter().map(|(id, s)| (id.clone(), s.pid)).collect()
    }
}

pub struct SessionStart;
#[async_trait]
impl Tool for SessionStart {
    fn name(&self) -> &str { "session_start" }
    fn description(&self) -> &str { "Start a persistent debug session. Args: path (exe) OR pid (attach). Returns session_id." }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("path", "string", false, "Path to executable to debug"),
            ParamDef::new("pid", "number", false, "Process ID to attach to"),
        ])
    }
    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        let mut store = get_sessions().lock().unwrap();
        
        let session_id = if let Some(pid) = args["pid"].as_u64() {
            store.create_session("", Some(pid as u32)).map_err(|e| anyhow::anyhow!("{}", e))?
        } else if let Some(path) = args["path"].as_str() {
            store.create_session(path, None).map_err(|e| anyhow::anyhow!("{}", e))?
        } else {
            return Ok(StandardResponse::error(tool_name, "Provide 'path' or 'pid'"));
        };

        std::thread::sleep(std::time::Duration::from_millis(500));
        let output = store.send_command(&session_id, "").unwrap_or_default();
        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({ "session_id": session_id, "startup_output": output.join("\n") }), start))
    }
}

pub struct SessionCommand;
#[async_trait]
impl Tool for SessionCommand {
    fn name(&self) -> &str { "session_command" }
    fn description(&self) -> &str { "Send command to debug session. Args: session_id, command (string)" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("session_id", "string", true, "Debug session ID"),
            ParamDef::new("command", "string", true, "Debugger command to execute"),
        ])
    }
    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        let session_id = args["session_id"].as_str().ok_or(anyhow::anyhow!("Missing session_id"))?;
        let command = args["command"].as_str().ok_or(anyhow::anyhow!("Missing command"))?;
        let mut store = get_sessions().lock().unwrap();
        let output = store.send_command(session_id, command).unwrap_or_default();
        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({ "session_id": session_id, "command": command, "output": output }), start))
    }
}

pub struct SessionBatch;
#[async_trait]
impl Tool for SessionBatch {
    fn name(&self) -> &str { "session_batch" }
    fn description(&self) -> &str { "Send multiple commands to session. Args: session_id, commands (array)" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![
            ParamDef::new("session_id", "string", true, "Debug session ID"),
            ParamDef::new("commands", "array", true, "Array of debugger commands"),
        ])
    }
    async fn execute(&self, args: Value) -> Result<Value> {
        let start = Instant::now();
        let tool_name = self.name();
        let session_id = args["session_id"].as_str().ok_or(anyhow::anyhow!("Missing session_id"))?;
        let commands: Vec<String> = args["commands"].as_array().map(|a| a.iter().filter_map(|v| v.as_str().map(String::from)).collect()).unwrap_or_default();
        let mut store = get_sessions().lock().unwrap();
        let mut results = Vec::new();
        for cmd in &commands {
            let output = store.send_command(session_id, cmd).unwrap_or_default();
            results.push(serde_json::json!({ "command": cmd, "output": output }));
        }
        Ok(StandardResponse::success_timed(tool_name, serde_json::json!({ "session_id": session_id, "results": results }), start))
    }
}

pub struct SessionEnd;
#[async_trait]
impl Tool for SessionEnd {
    fn name(&self) -> &str { "session_end" }
    fn description(&self) -> &str { "End a debug session. Args: session_id" }
    fn schema(&self) -> ToolSchema {
        ToolSchema::new(vec![ ParamDef::new("session_id", "string", true, "Debug session ID") ])
    }
    async fn execute(&self, args: Value) -> Result<Value> {
        let tool_name = self.name();
        let session_id = args["session_id"].as_str().ok_or(anyhow::anyhow!("Missing session_id"))?;
        let mut store = get_sessions().lock().unwrap();
        store.end_session(session_id)?;
        Ok(StandardResponse::success(tool_name, serde_json::json!({ "session_id": session_id, "ended": true })))
    }
}

pub struct SessionList;
#[async_trait]
impl Tool for SessionList {
    fn name(&self) -> &str { "session_list" }
    fn description(&self) -> &str { "List all active debug sessions" }
    fn schema(&self) -> ToolSchema { ToolSchema::empty() }
    async fn execute(&self, _args: Value) -> Result<Value> {
        let tool_name = self.name();
        let store = get_sessions().lock().unwrap();
        let sessions: Vec<_> = store.list_sessions().into_iter().map(|(id, pid)| serde_json::json!({ "session_id": id, "cdb_pid": pid })).collect();
        Ok(StandardResponse::success(tool_name, serde_json::json!({ "active_sessions": sessions, "count": sessions.len() })))
    }
}

pub struct CdbCommands;
#[async_trait]
impl Tool for CdbCommands {
    fn name(&self) -> &str { "debug_help" }
    fn description(&self) -> &str { "Get common cdb.exe debugger commands reference" }
    fn schema(&self) -> ToolSchema { ToolSchema::empty() }
    async fn execute(&self, _args: Value) -> Result<Value> {
        let tool_name = self.name();
        Ok(StandardResponse::success(tool_name, serde_json::json!({
            "workflow": ["1. session_start(path='exe') â†’ session_id", "2. session_command(id, 'bp main')", "3. session_command(id, 'g')", "4. session_end(id)"],
            "commands": { "g": "Go", "p": "Step", "t": "Trace", "bp": "Breakpoint", "db/dd/dq": "Memory", "u": "Disasm", "r": "Registers", "k": "Stack" }
        })))
    }
}
