use anyhow::Result;
use serde_json::Value;
use crate::tools::Tool;
use crate::engine::frida_handler;
use async_trait::async_trait;

/// Execution Stalker - Traces CPU instruction flow using Frida Stalker
pub struct ExecutionStalker;

#[async_trait]
impl Tool for ExecutionStalker {
    fn name(&self) -> &str { "trace_execution" }
    fn description(&self) -> &str { "Traces CPU execution flow (basic blocks) using Frida Stalker. Args: pid (number), duration_ms (default 5000)" }

    async fn execute(&self, args: Value) -> Result<Value> {
        let pid = args["pid"].as_u64().ok_or(anyhow::anyhow!("Missing pid"))? as u32;
        let duration = args["duration_ms"].as_u64().unwrap_or(5000);

        let script = format!(r#"
            var threads = Process.enumerateThreads();
            var targetThreadId = threads[0].id;

            console.log("[*] Stalking thread: " + targetThreadId);

            var blocks = {{}};
            var blockCount = 0;
            var eventQueue = [];
            var lastFlush = Date.now();
            var BATCH_SIZE = 50;
            var FLUSH_INTERVAL = 1000;

            function flushEvents() {{
                if (eventQueue.length > 0) {{
                    send({{ "type": "block_batch", "count": eventQueue.length, "addresses": eventQueue }});
                    eventQueue = [];
                    lastFlush = Date.now();
                }}
            }}

            Stalker.follow(targetThreadId, {{
                events: {{
                    call: false,
                    ret: false,
                    exec: false,
                    block: true,
                    compile: false
                }},
                onReceive: function (events) {{
                    var evs = Stalker.parse(events, {{ annotate: false, bigEndian: false }});
                    evs.forEach(function (ev) {{
                        var start = ev[0];
                        var addr = start.toString();
                        if (!blocks[addr]) {{
                            blocks[addr] = 1;
                            blockCount++;
                            eventQueue.push(addr);
                        }}
                    }});

                    // Batch flush: every 50 blocks or every second
                    if (eventQueue.length >= BATCH_SIZE || Date.now() - lastFlush > FLUSH_INTERVAL) {{
                        flushEvents();
                    }}
                }}
            }});

            setTimeout(function() {{
                flushEvents(); // Final flush
                Stalker.unfollow(targetThreadId);
                Stalker.garbageCollect();
                send({{ "type": "stalking_complete", "unique_blocks": blockCount }});
            }}, {});
        "#, duration);

        frida_handler::execute_script(pid, &script)?;

        Ok(serde_json::json!({
            "status": "stalking_started",
            "pid": pid,
            "duration_ms": duration,
            "note": "Execution blocks will be streamed via Frida messages"
        }))
    }
}
